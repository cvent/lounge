<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>basemodel.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AbstractBaseModel.html">AbstractBaseModel</a><ul class='methods'><li data-type='method'><a href="AbstractBaseModel.html#clear">clear</a></li><li data-type='method'><a href="AbstractBaseModel.html#clearErrors">clearErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#get">get</a></li><li data-type='method'><a href="AbstractBaseModel.html#getErrors">getErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#hasErrors">hasErrors</a></li><li data-type='method'><a href="AbstractBaseModel.html#inspect">inspect</a></li><li data-type='method'><a href="AbstractBaseModel.html#set">set</a></li><li data-type='method'><a href="AbstractBaseModel.html#toJSON">toJSON</a></li><li data-type='method'><a href="AbstractBaseModel.html#toObject">toObject</a></li><li data-type='method'><a href="AbstractBaseModel.html#toString">toString</a></li></ul></li><li><a href="BaseModel.html">BaseModel</a></li><li><a href="CouchbaseDocument.html">CouchbaseDocument</a><ul class='methods'><li data-type='method'><a href="CouchbaseDocument.html#.findById">findById</a></li><li data-type='method'><a href="CouchbaseDocument.html#.remove">remove</a></li><li data-type='method'><a href="CouchbaseDocument.html#getCAS">getCAS</a></li><li data-type='method'><a href="CouchbaseDocument.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="CouchbaseDocument.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="CouchbaseDocument.html#index">index</a></li><li data-type='method'><a href="CouchbaseDocument.html#remove">remove</a></li><li data-type='method'><a href="CouchbaseDocument.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="CouchbaseDocument.html#save">save</a></li></ul></li><li><a href="Document.html">Document</a><ul class='methods'><li data-type='method'><a href="Document.html#.getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Document.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="Document.html#getDocumentKeyValue">getDocumentKeyValue</a></li></ul></li><li><a href="Lounge.html">Lounge</a><ul class='methods'><li data-type='method'><a href="Lounge.html#connect">connect</a></li><li data-type='method'><a href="Lounge.html#disconnect">disconnect</a></li><li data-type='method'><a href="Lounge.html#getModel">getModel</a></li><li data-type='method'><a href="Lounge.html#getOption">getOption</a></li><li data-type='method'><a href="Lounge.html#model">model</a></li><li data-type='method'><a href="Lounge.html#modelNames">modelNames</a></li><li data-type='method'><a href="Lounge.html#schema">schema</a></li><li data-type='method'><a href="Lounge.html#setOption">setOption</a></li></ul></li><li><a href="MemoDriver.html">MemoDriver</a></li><li><a href="Model.html">Model</a><ul class='methods'><li data-type='method'><a href="Model.html#getCAS">getCAS</a></li><li data-type='method'><a href="Model.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="Model.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Model.html#index">index</a></li><li data-type='method'><a href="Model.html#remove">remove</a></li><li data-type='method'><a href="Model.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="Model.html#save">save</a></li></ul></li><li><a href="ModelInstance.html">ModelInstance</a><ul class='methods'><li data-type='method'><a href="ModelInstance.html#getCAS">getCAS</a></li><li data-type='method'><a href="ModelInstance.html#getDocumentKeyKey">getDocumentKeyKey</a></li><li data-type='method'><a href="ModelInstance.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="ModelInstance.html#index">index</a></li><li data-type='method'><a href="ModelInstance.html#remove">remove</a></li><li data-type='method'><a href="ModelInstance.html#removeIndexes">removeIndexes</a></li><li data-type='method'><a href="ModelInstance.html#save">save</a></li></ul></li><li><a href="ObjectArray.html">ObjectArray</a></li><li><a href="PlainBaseModel.html">PlainBaseModel</a></li><li><a href="Schema.html">Schema</a><ul class='methods'><li data-type='method'><a href="Schema.html#add">add</a></li><li data-type='method'><a href="Schema.html#extend">extend</a></li><li data-type='method'><a href="Schema.html#get">get</a></li><li data-type='method'><a href="Schema.html#getDocumentKeyValue">getDocumentKeyValue</a></li><li data-type='method'><a href="Schema.html#getRefKey">getRefKey</a></li><li data-type='method'><a href="Schema.html#hasRefPath">hasRefPath</a></li><li data-type='method'><a href="Schema.html#method">method</a></li><li data-type='method'><a href="Schema.html#post">post</a></li><li data-type='method'><a href="Schema.html#pre">pre</a></li><li data-type='method'><a href="Schema.html#set">set</a></li><li data-type='method'><a href="Schema.html#static">static</a></li><li data-type='method'><a href="Schema.html#virtual">virtual</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">basemodel.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { EventEmitter } from 'events';
import _ from 'lodash';
import clone from 'clone';

import _privateKey from './privatekey';
import { getFunctionName } from './utils';
import { defineProperty, clearField } from './basemodel.utils';

const tempEmitter = new EventEmitter();
const eventEmmiterInternals = Object.getOwnPropertyNames(tempEmitter);

function build(extendEventEmitter) {
  let ParentClass = class {};

  if (extendEventEmitter) {
    ParentClass = EventEmitter;
  }

  class AbstractBaseModel extends ParentClass {
    /**
     * @classdesc Abstract Base Model representation for all created Document instances.
     * Represents just the document data and generic properties and functions.
     * Also used for "object" abstraction / representation of sub documents that are not actual Models / Documents.
     * Clients should never have to call this directly.
     *
     * @description Clients do not need to create &lt;code>AbstractBaseModel&lt;/code> instances manually.
     * @class
     * @param {Object} values - the object data
     * @param {Object} options - creation options
     * @param {Boolean} options.clone - Whether to deep clone the incoming data. Default: &lt;code>false&lt;/code>.
     *                                  Make sure you wish to do this as it has performance implications. This is
     *                                  useful if you are creating multiple instances from same base data and then
     *                                  wish to modify each instance.
     * @param {Schema} schema - schema instance
     * @returns {AbstractBaseModel}
     */
    constructor(values, options, schema) {
      super();

      // Object used to store internals.
      const _private = this[_privateKey] = {};

      // Object with getters and setters bound.
      _private._getset = this;

      // Public version of ourselves.
      // Overwritten with proxy if available.
      _private._this = this;

      // Object used to store raw values.
      _private._obj = {};

      _private.schema = schema;

      // Errors, retrieved with getErrors().
      _private._errors = [];

      // Define getters/typecasts based off of schema.
      _.each(schema.descriptor, (properties, index) => {
        // Use getter / typecast to intercept and re-route, transform, etc.
        defineProperty.call(_private._getset, index, properties);
      });

      // Proxy used as interface to object allows to intercept all access.
      // Without Proxy we must register individual getter/typecasts to put any logic in place.
      // With Proxy, we still use the individual getter/typecasts, but also catch values that aren't in the schema.
      if (typeof Proxy !== 'undefined') {
        const proxy = this[_privateKey]._this = new Proxy(this, {
          // Ensure only public keys are shown
          ownKeys: (target) => {
            return Object.keys(this.toObject());
          },

          // Return keys to iterate
          enumerate: (target) => {
            return Object.keys(this[_privateKey]._this)[Symbol.iterator]();
          },

          // Check to see if key exists
          has: (target, key) => {
            return Boolean(_private._getset[key]);
          },

          // Ensure correct prototype is returned.
          getPrototypeOf: () => {
            return _private._getset;
          },

          // Ensure readOnly fields are not writeable.
          getOwnPropertyDescriptor: (target, key) => {
            return {
              value: proxy[key],
              writeable: !schema.descriptor[key] || schema.descriptor[key].readOnly !== true,
              enumerable: true,
              configurable: true
            };
          },

          // Intercept all get calls.
          get: (target, name, receiver) => {
            // Support dot notation via lodash.
            if (this.schema.options.dotNotation &amp;&amp; typeof name === 'string' &amp;&amp; name.indexOf('.') !== -1) {
              return _.get(this[_privateKey]._this, name);
            }

            // Use registered getter without hitting the proxy to avoid creating an infinite loop.
            return this[name];
          },

          // Intercept all set calls.
          set: (target, name, value, receiver) => {
            // Support dot notation via lodash.
            if (this.schema.options.dotNotation &amp;&amp; typeof name === 'string' &amp;&amp; name.indexOf('.') !== -1) {
              _.set(this[_privateKey]._this, name, value);
              return true;
            }

            if (!schema.descriptor[name]) {
              if (extendEventEmitter &amp;&amp; eventEmmiterInternals.indexOf(name) >= 0) {
                return true;
              }

              if (this.schema.options.strict) {
                // Strict mode means we don't want to deal with anything not in the schema.
                // TODO: SetterError here.
                return false;
              }

              // Add index to schema dynamically when value is set.
              // This is necessary for toObject to see the field.
              this._addToSchema(name, {
                type: 'any'
              });
            }

            // This hits the registered setter but bypasses the proxy to avoid an infinite loop.
            this[name] = value;
            return true;
          },

          // Intercept all delete calls.
          deleteProperty: (target, property) => {
            this[property] = undefined;
            return true;
          }
        });
      }

      // Populate schema defaults into object.
      _.each(schema.descriptor, (properties, index) => {
        if (properties.default !== undefined) {
          // Temporarily ensure readOnly is turned off to prevent the set from failing.
          const readOnly = properties.readOnly;
          properties.readOnly = false;
          this[index] = _.isFunction(properties.default) ? properties.default.call(this) : clone(properties.default);
          properties.readOnly = readOnly;
        }
      });

      // Populate runtime values as provided to this instance of object.
      if (_.isObject(values)) {
        let data = values;
        if (options.clone) {
          data = clone(values);
        }
        this.set(data);
      }

      // May return actual object instance or Proxy, depending on harmony support.
      return _private._this;
    }

    /**
     * Get the model schema instance
     * @public
     * @returns {Schema}
     */
    get schema() {
      return this[_privateKey].schema;
    }

    // Add field to schema and initializes getter and setter for the field.
    _addToSchema(index, properties) {
      this.schema.add(index, properties);
      defineProperty.call(this[_privateKey]._getset, index, this.schema.descriptor[index]);
    }

    /**
     * Sets data on the document based on the schema.
     * Accepts a key of property and value for the property, or object representing the data for document.
     *
     * @public
     * @example
     * user.set('fistName', 'Joe');
     * user.set({ lastName: 'Smith' });
     */
    set(path, value) {
      if (_.isObject(path) &amp;&amp; !value) {
        value = path;
        for (const key in value) {
          if (value.hasOwnProperty(key)) {
            try {
              this[_privateKey]._this[key] = value[key];
            } catch (err) {}
          }
        }
      } else {
        try {
          this[_privateKey]._this[path] = value;
        } catch (err) {}
      }
    }

    /**
     * Gets value at a specified path.
     * @param  {String} path The path / property to retrieve.
     * @return {*}      The value at the path.
     */
    get(path) {
      return this[path];
    }

    _prepareToObjectOptions(options, json) {
      const defaultOptions = {
        transform: true,
        json,
        minimize: true
      };

      // When internally saving this document we always pass options,
      // bypassing the custom schema options.
      if (!(options &amp;&amp; getFunctionName(options.constructor) === 'Object') ||
        (options &amp;&amp; options._useSchemaOptions)) {
        if (json) {
          options = this.schema.options.toJSON ?
            clone(this.schema.options.toJSON) : {};
          options.json = true;
          options._useSchemaOptions = true;
        } else {
          options = this.schema.options.toObject ?
            clone(this.schema.options.toObject) : {};
          options.json = false;
          options._useSchemaOptions = true;
        }
      }

      for (const key in defaultOptions) {
        if (defaultOptions.hasOwnProperty(key) &amp;&amp; options[key] === undefined) {
          options[key] = defaultOptions[key];
        }
      }

      return options;
    }

    /**
     *
     * @param options
     * @param json
     * @returns {{}}
     * @private
     */
    _toObject(options, json) {
      options = this._prepareToObjectOptions(options, json);

      // remember the root transform function
      // to save it from being overwritten by sub-transform functions
      const originalTransform = options.transform;

      let ret = {};

      // Populate all properties in schema.
      _.each(this.schema.descriptor, (properties, index) => {
        // Do not write values to object that are marked as invisible.
        if (properties.invisible &amp;&amp; !properties.virtual) {
          return;
        }

        if (properties.virtual &amp;&amp; !options.virtuals) {
          return;
        }

        if (properties.serializable === false &amp;&amp; options.serializable === false) {
          return;
        }

        // Fetch value through the public interface.
        let value = this[_privateKey]._this[index];

        if (options.minimize &amp;&amp; (_.isUndefined(value) || _.isNull(value))) {
          return;
        }

        // Clone objects so they can't be modified by reference.
        if (typeof value === 'object' &amp;&amp; value) {
          if (value._isBaseModel) {
            if (options &amp;&amp; options.json &amp;&amp; typeof value.toJSON === 'function') {
              value = value.toJSON(options);
            } else {
              value = value.toObject(options);
            }
          } else if (value._isObjectArray) {
            value = value.toArray();
          } else if (_.isArray(value)) {
            value = value.splice(0);
          } else if (_.isDate(value)) {
            // https://github.com/documentcloud/underscore/pull/863
            // _.clone doesn't work on Date object.
            const d = new Date(value.getTime());
            if (options.dateToISO === true) {
              ret[index] = d.toISOString();
            } else {
              ret[index] = new Date(value.getTime());
            }
          } else {
            value = _.clone(value);
          }

          // Don't write empty objects or arrays.
          if (!_.isDate(value) &amp;&amp; options.minimize &amp;&amp; !_.size(value)) {
            return;
          }
        }

        // Write to object.
        ret[index] = value;
      });

      let transform = options.transform;

      // In the case where a subdocument has its own transform function, we need to
      // check and see if the parent has a transform (options.transform) and if the
      // child schema has a transform (this.schema.options.toObject) In this case,
      // we need to adjust options.transform to be the child schema's transform and
      // not the parent schema's
      if (transform === true || (this.schema.options.toObject &amp;&amp; transform)) {
        const opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;

        if (opts) {
          transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
        }
      } else {
        options.transform = originalTransform;
      }

      if (typeof transform === 'function') {
        const xformed = transform(this, ret, options);
        if (typeof xformed !== 'undefined') {
          ret = xformed;
        }
      }

      return ret;
    }

    /**
     * Converts this document into a plain javascript object.
     *
     * @public
     * @param {Object} options
     * @param {Function} options.transform - a transform function to apply to the resulting document before returning.
     * @param {Boolean} options.virtuals - apply virtual getters. Default: &lt;code>false&lt;/code>
     * @param {Boolean} options.minimize - remove empty objects. Default: &lt;code>true&lt;/code>
     * @param {Boolean} options.serializable - whether to include &lt;code>serializable&lt;/code> properties. Default: &lt;code>true&lt;/code>
     * @param {Boolean} options.dateToISO - convert dates to string in ISO format using &lt;code>Date.toISOString()&lt;/code>. Default: &lt;code>true&lt;/code>
     *
     * @return {Object} Plain javascript object representation of document.
     *
     * @example
     * var userSchema = lounge.schema({ name: String });
     * var User = lounge.model('User', userSchema);
     * var user = new User({name: 'Joe Smith'});
     * console.log(user); // automatically invokes toObject()
     *
     * @example &lt;caption>Example with transform option.&lt;/caption>
     * var xform = function (doc, ret, options) {
     *   ret.name = ret.name.toUpperCase();
     *   return ret;
     * };
     * console.dir(user.toObject({transform: xform}); // { name: 'JOE SMITH' }
     */
    toObject(options) {
      return this._toObject(options);
    }

    /**
     * Similar as &lt;code>toObject&lt;/code> but applied when &lt;code>JSON.stringify&lt;/code> is called
     *
     * @public
     * @param {Object} options - Same options as &lt;code>toObject&lt;/code>.
     * @return {Object} Plain javascript object representation of document.
     */
    toJSON(options) {
      return this._toObject(options, true);
    }

    /**
     * Helper for &lt;code>console.log&lt;/code>. Just invokes default &lt;code>toObject&lt;/code>.
     * @public
     */
    inspect() {
      return this.toObject({});
    }

    /**
     * Helper for &lt;code>console.log&lt;/code>. Alias for &lt;code>inspect&lt;/code>.
     * @public
     */
    toString() {
      return this.inspect();
    }

    /**
     * Clear the document data.
     */
    clear() {
      _.each(this.schema.descriptor, (properties, index) => {
        clearField.call(this[_privateKey]._this, index, properties);
      });
    }

    /**
     * Gets the errors object.
     */
    getErrors() {
      return this[_privateKey]._errors;
    }

    /**
     * Clears all the errors.
     */
    clearErrors() {
      this[_privateKey]._errors.length = 0;
    }

    /**
     * Checks whether we have any errors.
     * @return {Boolean} &lt;code>true&lt;/code> if we have errors, &lt;code>false&lt;/code> otherwise.
     */
    hasErrors() {
      return Boolean(this[_privateKey]._errors.length);
    }

    /**
     * Used to detect instance of schema object internally.
     * @private
     */
    _isBaseModel() {
      return true;
    }
  }

  return AbstractBaseModel;
}

/**
 * @classdesc BaseModel implements &lt;code>AbstractBaseModel&lt;/code> and is a representation for all created Document
 * instances that have a user defined schema. Represents just the document data and generic properties and functions.
 * Clients should never have to call this directly. Inherits &lt;code>EventEmitter&lt;/code>
 *
 * @description Clients do not need to create &lt;code>BaseModel&lt;/code> instances manually.
 * @class
 * @augments EventEmitter
 */
const BaseModel = build(true);

/**
 * @classdesc PlainBaseModel implements &lt;code>AbstractBaseModel&lt;/code> and is a representation for embedded subdocument
 * objects within user defined models. Clients should never have to call this directly.
 *
 * @description Clients do not need to create &lt;code>PlainBaseModel&lt;/code> instances manually.
 * @class
 */
const PlainBaseModel = build();

export { BaseModel, PlainBaseModel };
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed Aug 10 2016 20:25:49 GMT-0300 (ADT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>

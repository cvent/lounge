<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Lounge</title>
    
    <meta name="description" content="Simple Mongoose-inspired ODM for Couchbase" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"Lounge","meta":{"title":"Lounge","description":"Simple Mongoose-inspired ODM for Couchbase","keyword":""},"linenums":true};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">Lounge</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">

    
        <li class="item" data-name="">
            <span class="title">
                <a href="-_.html"></a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="#cas"><a href="global.html#cas">cas</a></li>
            
                <li data-name="#config"><a href="global.html#config">config</a></li>
            
                <li data-name="#db"><a href="global.html#db">db</a></li>
            
                <li data-name="#modelName"><a href="global.html#modelName">modelName</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="#getCAS"><a href="global.html#getCAS">getCAS</a></li>
            
                <li data-name="#getDocumentKeyKey"><a href="global.html#getDocumentKeyKey">getDocumentKeyKey</a></li>
            
                <li data-name="#getDocumentKeyValue"><a href="global.html#getDocumentKeyValue">getDocumentKeyValue</a></li>
            
                <li data-name="#index"><a href="global.html#index">index</a></li>
            
                <li data-name="#remove"><a href="global.html#remove">remove</a></li>
            
                <li data-name="#removeIndexes"><a href="global.html#removeIndexes">removeIndexes</a></li>
            
                <li data-name="#save"><a href="global.html#save">save</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="AbstractBaseModel">
            <span class="title">
                <a href="AbstractBaseModel.html">AbstractBaseModel</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="AbstractBaseModel#schema"><a href="AbstractBaseModel.html#schema">schema</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="AbstractBaseModel#clear"><a href="AbstractBaseModel.html#clear">clear</a></li>
            
                <li data-name="AbstractBaseModel#clearErrors"><a href="AbstractBaseModel.html#clearErrors">clearErrors</a></li>
            
                <li data-name="AbstractBaseModel#get"><a href="AbstractBaseModel.html#get">get</a></li>
            
                <li data-name="AbstractBaseModel#getErrors"><a href="AbstractBaseModel.html#getErrors">getErrors</a></li>
            
                <li data-name="AbstractBaseModel#hasErrors"><a href="AbstractBaseModel.html#hasErrors">hasErrors</a></li>
            
                <li data-name="AbstractBaseModel#inspect"><a href="AbstractBaseModel.html#inspect">inspect</a></li>
            
                <li data-name="AbstractBaseModel#set"><a href="AbstractBaseModel.html#set">set</a></li>
            
                <li data-name="AbstractBaseModel#toJSON"><a href="AbstractBaseModel.html#toJSON">toJSON</a></li>
            
                <li data-name="AbstractBaseModel#toObject"><a href="AbstractBaseModel.html#toObject">toObject</a></li>
            
                <li data-name="AbstractBaseModel#toString"><a href="AbstractBaseModel.html#toString">toString</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="BaseModel">
            <span class="title">
                <a href="BaseModel.html">BaseModel</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="CouchbaseDocument">
            <span class="title">
                <a href="CouchbaseDocument.html">CouchbaseDocument</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="CouchbaseDocument#cas"><a href="CouchbaseDocument.html#cas">cas</a></li>
            
                <li data-name="CouchbaseDocument#config"><a href="CouchbaseDocument.html#config">config</a></li>
            
                <li data-name="CouchbaseDocument#db"><a href="CouchbaseDocument.html#db">db</a></li>
            
                <li data-name="CouchbaseDocument#modelName"><a href="CouchbaseDocument.html#modelName">modelName</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="CouchbaseDocument.findById"><a href="CouchbaseDocument.html#.findById">findById</a></li>
            
                <li data-name="CouchbaseDocument.remove"><a href="CouchbaseDocument.html#.remove">remove</a></li>
            
                <li data-name="CouchbaseDocument#getCAS"><a href="CouchbaseDocument.html#getCAS">getCAS</a></li>
            
                <li data-name="CouchbaseDocument#getDocumentKeyKey"><a href="CouchbaseDocument.html#getDocumentKeyKey">getDocumentKeyKey</a></li>
            
                <li data-name="CouchbaseDocument#getDocumentKeyValue"><a href="CouchbaseDocument.html#getDocumentKeyValue">getDocumentKeyValue</a></li>
            
                <li data-name="CouchbaseDocument#index"><a href="CouchbaseDocument.html#index">index</a></li>
            
                <li data-name="CouchbaseDocument#remove"><a href="CouchbaseDocument.html#remove">remove</a></li>
            
                <li data-name="CouchbaseDocument#removeIndexes"><a href="CouchbaseDocument.html#removeIndexes">removeIndexes</a></li>
            
                <li data-name="CouchbaseDocument#save"><a href="CouchbaseDocument.html#save">save</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Document">
            <span class="title">
                <a href="Document.html">Document</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Document#modelName"><a href="Document.html#modelName">modelName</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Document.getDocumentKeyValue"><a href="Document.html#.getDocumentKeyValue">getDocumentKeyValue</a></li>
            
                <li data-name="Document#getDocumentKeyKey"><a href="Document.html#getDocumentKeyKey">getDocumentKeyKey</a></li>
            
                <li data-name="Document#getDocumentKeyValue"><a href="Document.html#getDocumentKeyValue">getDocumentKeyValue</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Driver">
            <span class="title">
                <a href="Driver.html">Driver</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Driver.wrap"><a href="Driver.html#.wrap">wrap</a></li>
            
                <li data-name="Driver#get"><a href="Driver.html#get">get</a></li>
            
                <li data-name="Driver#remove"><a href="Driver.html#remove">remove</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Lounge">
            <span class="title">
                <a href="Lounge.html">Lounge</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="Lounge#CouchbaseDocument"><a href="Lounge.html#CouchbaseDocument">CouchbaseDocument</a></li>
            
                <li data-name="Lounge#Document"><a href="Lounge.html#Document">Document</a></li>
            
                <li data-name="Lounge#Lounge"><a href="Lounge.html#Lounge">Lounge</a></li>
            
                <li data-name="Lounge#Model"><a href="Lounge.html#Model">Model</a></li>
            
                <li data-name="Lounge#Schema"><a href="Lounge.html#Schema">Schema</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Lounge#connect"><a href="Lounge.html#connect">connect</a></li>
            
                <li data-name="Lounge#disconnect"><a href="Lounge.html#disconnect">disconnect</a></li>
            
                <li data-name="Lounge#getModel"><a href="Lounge.html#getModel">getModel</a></li>
            
                <li data-name="Lounge#getOption"><a href="Lounge.html#getOption">getOption</a></li>
            
                <li data-name="Lounge#model"><a href="Lounge.html#model">model</a></li>
            
                <li data-name="Lounge#modelNames"><a href="Lounge.html#modelNames">modelNames</a></li>
            
                <li data-name="Lounge#schema"><a href="Lounge.html#schema">schema</a></li>
            
                <li data-name="Lounge#setOption"><a href="Lounge.html#setOption">setOption</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="MemoDriver">
            <span class="title">
                <a href="MemoDriver.html">MemoDriver</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="MemoDriver#get"><a href="MemoDriver.html#get">get</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="MemoDriver#clear"><a href="MemoDriver.html#clear">clear</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="ModelInstance">
            <span class="title">
                <a href="ModelInstance.html">ModelInstance</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="ModelInstance.config"><a href="ModelInstance.html#.config">config</a></li>
            
                <li data-name="ModelInstance.db"><a href="ModelInstance.html#.db">db</a></li>
            
                <li data-name="ModelInstance.modelName"><a href="ModelInstance.html#.modelName">modelName</a></li>
            
                <li data-name="ModelInstance.schema"><a href="ModelInstance.html#.schema">schema</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="ObjectArray">
            <span class="title">
                <a href="ObjectArray.html">ObjectArray</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="PlainBaseModel">
            <span class="title">
                <a href="PlainBaseModel.html">PlainBaseModel</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="Schema">
            <span class="title">
                <a href="Schema.html">Schema</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="Schema#add"><a href="Schema.html#add">add</a></li>
            
                <li data-name="Schema#extend"><a href="Schema.html#extend">extend</a></li>
            
                <li data-name="Schema#get"><a href="Schema.html#get">get</a></li>
            
                <li data-name="Schema#getDocumentKeyValue"><a href="Schema.html#getDocumentKeyValue">getDocumentKeyValue</a></li>
            
                <li data-name="Schema#getRefKey"><a href="Schema.html#getRefKey">getRefKey</a></li>
            
                <li data-name="Schema#hasRefPath"><a href="Schema.html#hasRefPath">hasRefPath</a></li>
            
                <li data-name="Schema#method"><a href="Schema.html#method">method</a></li>
            
                <li data-name="Schema#post"><a href="Schema.html#post">post</a></li>
            
                <li data-name="Schema#pre"><a href="Schema.html#pre">pre</a></li>
            
                <li data-name="Schema#set"><a href="Schema.html#set">set</a></li>
            
                <li data-name="Schema#static"><a href="Schema.html#static">static</a></li>
            
                <li data-name="Schema#virtual"><a href="Schema.html#virtual">virtual</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="cbdocument.js.html">Source: cbdocument.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _ = require('lodash');
const async = require('async');
const mpath = require('mpath');
const debug = require('debug')('lounge');
const clone = require('clone');

const MemoDriver = require('./memodriver');
const cdocUtils = require('./cbdocument.utils.js');
const utils = require('./utils');

import Document from './document';
import _privateKey from './privatekey';

export default class CouchbaseDocument extends Document {
  /**
   * @classdesc CouchbaseDocument inherits Document and handles all the database related actions.
   * Clients should never have to call this directly.
   *
   * @description Clients do not need to create Document manually.
   * @class
   * @augments Document
   * @param {Object} values - the object data
   * @param {Object} cas - the Couchbase &lt;code>CAS&lt;/code> value for the document
   * @param {Object} options - creation options
   * @param {Boolean} options.clone - Whether to deep clone the incoming data. Default: &lt;code>false&lt;/code>.
   *                                  Make sure you wish to do this as it has performance implications. This is
   *                                  useful if you are creating multiple instances from same base data and then
   *                                  wish to modify each instance.
   * @param {Schema} schema - schema instance
   * @param {String} name - the model name
   * @returns {CouchbaseDocument}
   */
  constructor(values, cas, options, schema, name) {
    super(values, options, schema, name);

    this[_privateKey].cas = cas;

    this[_privateKey]._o = {
      refValues: {},
      key: null
    };

    _.merge(this[_privateKey]._o.refValues, cdocUtils.buildRefValues(this.schema.indexes, values));
    this[_privateKey]._o.key = this.getDocumentKeyValue();
  }

  /**
   * Returns the string representation of &lt;code>CAS&lt;/code> value.
   * @example
   * console.log(doc.cas); // String: 00000000a71626e4
   * @returns {String}
   */
  get cas() {
    return this.getCAS();
  }

  /**
   * Gets the database driver of the model
   * @returns {Driver|null}
   */
  get db() {
    return this[_privateKey].db;
  }

  /**
   * Gets the config object
   * @returns {Object}
   */
  get config() {
    return this[_privateKey].config;
  }

  /**
   * Returns the document &lt;code>CAS&lt;/code> value.
   * @param {Boolean} raw - If &lt;code>true&lt;/code> returns the raw CAS document. If &lt;code>false&lt;/code> returns string
   *                        representation of CAS. Defaults to &lt;code>false&lt;/code>.
   * @returns {String|Object} the CAS value
   * @example
   * console.log(doc.getCAS()); // String: 00000000a71626e4
   * console.log(doc.getCAS(true)); // Object: CouchbaseCas&lt;11338961768815788032>
   */
  getCAS(raw) {
    if (raw) {
      return this[_privateKey].cas;
    }

    let v = '';
    const cas = this[_privateKey].cas;

    if (typeof cas === 'object') {
      let p;
      for (p in cas) {
        if (cas.hasOwnProperty(p) &amp;&amp; cas[p]) {
          if (Buffer.isBuffer(cas[p])) {
            v = v.concat(cas[p].toString('hex'));
          } else {
            v = v.concat(cas[p].toString());
          }
        }
      }
    }

    if (cas &amp;&amp; (!v || !v.trim().length)) {
      v = cas.toString();
    }

    return v;
  }

  /**
   * Save the current model instance. Calls db set function for the model id and saves the properties.
   * @param {Object} options The save options. All options not present here are first looked up from schema options,
   * and then from config options.
   * @param {Boolean} options.storeFullReferenceId - whether to save embedded document property values as full document keys or just the base value
   * @param {Boolean} options.storeFullKey - whether to save the internal document key property as fully expanded value or as the simple value
   * @param {String} options.refIndexKeyPrefix - lookup index document key prefix.
   * @param {Boolean} options.waitForIndex - whether we want to wait for indexing to finish before returning. Default: &lt;code>false&lt;/code>.
   * @param {Boolean} options.virtuals - whether we want to save virtuals. Default: &lt;code>false&lt;/code>.
   * @param {Boolean} options.minimize - to "minimize" the document by removing any empty properties. Default: &lt;code>true&lt;/code>
   * @param {Number} options.expiry - couchbase upsert option
   * @param {Number} options.persist_to - couchbase persist_to option
   * @param {Number} replicate_to - couchbase option
   * @param {Function} fn callback
   * @example
   * var user = new User({ name: 'Bob Smith', email: 'bsmith@acme.com' });
   * user.save(function(err, savedDoc) {
   *   if(err) console.log(err);
   * });
   */
  save(options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    options = _.defaults(options || {},
      _.pick(this.schema.options, utils.saveOptionsKeys),
      _.pick(this.config, utils.saveOptionsKeys));

    if (process.env.LOUNGE_DEBUG_FORCE_SAVE_FAIL) {
      return process.nextTick(() => {
        return fn(new Error('Forced save error'));
      });
    }

    const changedRefs = [];

    // iteratively save the refs
    const refs = this._getSortedRefPaths(true);
    if (refs &amp;&amp; refs.length > 0) {
      async.eachLimit(refs, 10, (path, eachCB) => {
        this._saveRef(path, changedRefs, options, eachCB);
      }, err => {
        if (err) {
          this._broadcast('error', err, this);
          return fn(err);
        }
        this._indexAndSave(changedRefs, options, fn);
      });
    } else {
      this._indexAndSave(changedRefs, options, fn);
    }
  }

  /*!
   * Save the ref at path
   * @param path
   * @param fn
   */
  _saveRef(path, changedRefs, options, fn) {
    const thing = mpath.get(path, this);

    if (_.isUndefined(thing) || _.isNull(thing)) {
      return fn();
    }

    if (!_.isArray(thing)) {
      if (thing instanceof CouchbaseDocument) {
        changedRefs.push({
          path,
          value: thing
        });
      }

      this._saveRefField(this, path, thing, options, fn);
    } else if (_.isArray(thing)) {
      const idArray = [];
      async.forEachOfLimit(thing, 10, (thingDoc, key, arrayCB) => {
        if (thingDoc instanceof CouchbaseDocument) {
          changedRefs.push({
            path: path.concat('.', key),
            value: thingDoc
          });
        }

        this._saveRefField(idArray, path, thingDoc, options, arrayCB);
      }, err => {
        if (!err) {
          mpath.set(path, idArray, this);
        }
        return fn(err);
      });
    }
  }

  /*!
   * Indexes this instance and saves it afterwards
   * @param changedRefs
   * @param options
   * @param fn callback
   */
  _indexAndSave(changedRefs, options, fn) {
    if (options.waitForIndex === true ||
      (_.isUndefined(options.waitForIndex) &amp;&amp; this.config.waitForIndex === true)) {
      this.index(options, err => {
        if (err) {
          this._broadcast('error', err, this);
          return fn(err);
        }

        return this._save(changedRefs, options, fn);
      });
    } else {
      this.index(options);
      return this._save(changedRefs, options, fn);
    }
  }

  /*!
   * Saves this instance
   * @param changedRefs
   * @param options
   * @param fn
   */
  _save(changedRefs, options, fn) {
    const toObjectOpts = {
      expandDocumentKey: options.storeFullKey || this.config.storeFullKey,
      virtuals: options.virtuals || false,
      transform: false,
      minimize: options.minimize || false,
      dateToISO: true,
      serializable: false
    };

    const doc = this.toObject(toObjectOpts);
    const id = this.getDocumentKeyValue(true);

    const opts = _.pick(options || {}, ['cas', 'expiry', 'persist_to', 'replicate_to']);

    debug(`save. type: ${this.modelName}  key: ${id}`);

    this.db.upsert(id, doc, opts, (err, res) => {
      if (changedRefs &amp;&amp; changedRefs.length > 0) {
        changedRefs.forEach(cr => {
          mpath.set(cr.path, cr.value, this);
        });
      }

      delete this[_privateKey].cas;
      this[_privateKey].cas = res.cas;

      delete this[_privateKey]._o.refValues;
      this[_privateKey]._o.refValues = {};
      _.merge(this[_privateKey]._o.refValues, cdocUtils.buildRefValues(this.schema.indexes, this));

      if (!err) {
        this._broadcast('save', this, options);
      }

      return fn(err, this);
    });
  }

  /**
   * Update all lookup documents for this document instance. Creates new lookup documents for properties that have changed
   * and deletes the old ones not needed any more.
   * @param {Object} options
   * @param {Boolean} options.storeFullReferenceId - whether we store full document id in reference documents
   * @param {Function} fn callback
   */
  index(options, fn) {
    const defaults = {
      storeFullReferenceId: _.isUndefined(this.schema.options.storeFullReferenceId) ?
        this.config.storeFullReferenceId : this.schema.options.storeFullReferenceId
    };

    if (typeof options === 'function') {
      fn = options;
      options = defaults;
    }

    if (!fn || typeof fn !== 'function') {
      fn = _.noop;
    }

    options = _.defaults(options || {}, defaults);

    const currentRefValues = cdocUtils.buildRefValues(this.schema.indexes, this);

    const fieldsToRef = cdocUtils.buildIndexObjects(this[_privateKey]._o.refValues, currentRefValues);

    async.eachLimit(fieldsToRef, 10, (refObj, eaCb) => {
      this._indexField(refObj, options, eaCb);
    }, err => {
      if (!err) {
        this._broadcast('index', this, options);
      }
      return fn(err);
    });
  }

  /*!
   * Index document field
   */
  _indexField(obj, options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!obj.value) {
      return process.nextTick(fn);
    }

    const docKey = this.schema.getRefKey(obj.name, obj.value);
    const refKeyValue = this.getDocumentKeyValue(_.isUndefined(options.storeFullReferenceId) ?
      this.config.storeFullReferenceId : options.storeFullReferenceId);

    if (obj.indexType === 'array') {
      debug(`array index. operation: ${obj.action} key: ${docKey} refKeyValue: ${refKeyValue}`);
      this.db.get(docKey, (err, indexDoc) => {
        if (err) {
          this._broadcast('error', err, this);
          return fn(err);
        }

        // document doesn't exist and we have to remove a value. weird case. just return.
        if ((!indexDoc || !indexDoc.value) &amp;&amp; obj.action === 'remove') {
          return fn();
        }

        if (indexDoc &amp;&amp; indexDoc.value) {
          indexDoc = indexDoc.value;
        }

        if (!indexDoc) {
          indexDoc = {
            keys: []
          };
        }

        if (!indexDoc.keys || !Array.isArray(indexDoc.keys)) {
          indexDoc.keys = [];
        }

        if (indexDoc &amp;&amp; indexDoc.keys &amp;&amp; Array.isArray(indexDoc.keys)) {
          const valueIndex = indexDoc.keys.indexOf(refKeyValue);
          if (obj.action === 'remove' &amp;&amp; valueIndex >= 0) {
            indexDoc.keys.splice(valueIndex, 1);
          } else if (valueIndex === -1) {
            indexDoc.keys.push(refKeyValue);
          }

          if (indexDoc.keys.length) {
            this.db.upsert(docKey, indexDoc, fn);
          } else {
            // no indexes. remove the document
            this.db.remove(docKey, fn);
          }
        } else {
          return fn();
        }
      });
    } else {
      const args = obj.action === 'remove' ? [docKey, fn] : [docKey, {
        key: refKeyValue
      }, fn];

      debug(`single index. operation: ${obj.action} key: ${docKey} refKeyValue: ${refKeyValue}`);

      return this.db[obj.action](...args);
    }
  }

  _getSortedRefPaths(reverse) {
    let refs = [];

    if (this.schema.refs) {
      for (const key in this.schema.refs) {
        if (this.schema.refs.hasOwnProperty(key)) {
          refs.push(this.schema.refs[key].path);
        }
      }

      if (refs.length > 0) {
        refs = _.sortBy(refs, 'length');
        if (reverse) {
          refs.reverse();
        }
      }
    }

    return refs;
  }

  /*!
   * Gers the model at a reference path
   * @param {String} path
   * @returns {*}
   */
  _getRefModel(path) {
    let model;
    if (this.schema.refs) {
      const modelName = this.schema.refs[path].ref;
      if (modelName) {
        model = this.db.models[modelName];
      }
    }

    return model;
  }

  /*!
   * Save embedded document field at a path
   * @param doc
   * @param path
   * @param thing
   * @param options
   * @param fn
   * @returns {*}
   */
  _saveRefField(doc, path, thing, options, fn) {
    const self = this;

    function saveRefDoc(couchDoc) {
      couchDoc.save(options, err => {
        if (err) {
          this._broadcast('error', err, couchDoc);
          fn(err);
        } else {
          const value = couchDoc.getDocumentKeyValue(self.config.storeFullReferenceId);

          if (Array.isArray(doc)) {
            doc.push(value);
          } else if (doc instanceof CouchbaseDocument || utils.isPlainObject(doc)) {
            mpath.set(path, value, doc);
          }

          fn();
        }
      });
    }

    if (thing instanceof CouchbaseDocument) {
      saveRefDoc(thing);
    } else if (_.isString(thing)) {
      return fn();
    } else if (utils.isPlainObject(thing)) {
      const RefModel = this._getRefModel(path);
      if (RefModel) {
        const instance = new RefModel(thing);
        saveRefDoc(instance);
      } else {
        console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
      }
    }
  }

  /**
   * Removes the instance from the database.
   * Calls the bucket &lt;code>remove()&lt;/code> function. Options can be passed to the driver.
   * @param {Object} options Options to be passed to the Couchbase `Bucket.remove()` function.
   * @param {Function} fn callback
   * @example
   * user.remove(function(err, doc) {
   *   if(err) console.log(err);
   * });
   */
  remove(options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!options) {
      options = {};
    }

    if (process.env.LOUNGE_DEBUG_FORCE_REMOVE_FAIL) {
      return process.nextTick(() => {
        return fn(new Error('Forced remove error'));
      });
    }

    if (options.removeRefs === true) {
      const refs = this._getSortedRefPaths(true);
      if (refs &amp;&amp; refs.length > 0) {
        async.eachLimit(refs, 10, (path, eachCB) => {
          const thing = mpath.get(path, this);

          if (_.isUndefined(thing) || _.isNull(thing)) {
            return eachCB();
          }

          if (!_.isArray(thing)) {
            return this._removeRefField(this, path, thing, options, eachCB);
          } else if (_.isArray(thing)) {
            const idArray = [];
            async.forEachOfLimit(thing, 10, (thingDoc, key, arrayCB) => {
              this._removeRefField(idArray, path, thingDoc, options, arrayCB);
            }, eachCB);
          } else {
            eachCB();
          }
        }, err => {
          if (err) {
            this._broadcast('error', err, this);
            return fn(err);
          }

          this._remove(options, fn);
        });
      } else {
        this._remove(options, fn);
      }
    } else {
      this._remove(options, fn);
    }
  }

  /*!
   * Remove embedded document at a path
   * @param doc
   * @param path
   * @param thing
   * @param options
   * @param fn
   * @returns {*}
   */
  _removeRefField(doc, path, thing, options, fn) {
    if (thing instanceof CouchbaseDocument) {
      return thing.remove(options, fn);
    }

    const RefModel = this._getRefModel(path);

    if (RefModel &amp;&amp; thing) {
      if (_.isString(thing)) {
        RefModel._findById(thing, {}, null, (err, doc) => {
          if (err) {
            this._broadcast('error', err, this);
            return fn(err);
          } else if (doc) {
            return doc.remove(options, fn);
          }

          return fn();
        });
      } else if (utils.isPlainObject(thing)) {
        const instance = new RefModel(thing);
        return instance.remove(options, fn);
      } else {
        console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
        return fn();
      }
    } else {
      console.error('ref at path \'%s\' is not a couchbase document and cannot fetch a ref model for it', path);
      return fn();
    }
  }

  /*!
   * Remove this document from database. Removes all index documents.
   * @param options
   * @param fn
   */
  _remove(options, fn) {
    const opts = _.pick(options || {}, ['cas', 'persist_to', 'replicate_to']);
    const key = this.getDocumentKeyValue(true);

    debug(`remove. key: ${key}`);

    this.db.remove(key, opts, err => {
      if (err) {
        this._broadcast('error', err, this);
        console.error('%s.$remove err: %j', this.modelName, err);
      } else {
        this._broadcast('remove', this, options);
        this.removeIndexes(options);
      }

      return fn(err, this);
    });
  }

  /**
   * Removes all lookup / index documents for this document.
   * @param {Object} options
   * @param {Boolean} options.storeFullReferenceId - whether we store full document id in reference documents
   * @param {Function} fn callback
   */
  removeIndexes(options, fn) {
    const defaults = {
      storeFullReferenceId: _.isUndefined(this.schema.options.storeFullReferenceId) ?
        this.config.storeFullReferenceId : this.schema.options.storeFullReferenceId
    };

    if (typeof options === 'function') {
      fn = options;
      options = defaults;
    }

    if (!fn || typeof fn !== 'function') {
      fn = _.noop;
    }

    options = _.defaults(options || {}, defaults);

    const currentRefValues = cdocUtils.buildRefValues(this.schema.indexes, this);

    const toRemove = _.union(_.values(currentRefValues), _.values(this[_privateKey]._o.refValues));

    // flatten arrays
    const toRemove2 = [];
    toRemove.forEach(e => {
      if (typeof e.value === 'string' || typeof e.value === 'number') {
        toRemove2.push(e);
      } else if (Array.isArray(e.value)) {
        e.value.forEach(ve => {
          toRemove2.push({
            path: e.path,
            name: e.name,
            indexType: e.indexType,
            value: ve
          });
        });
      }
    });

    // uniq
    const uniq = _.uniqWith(toRemove2, (arrVal, otherVal) => {
      const v1 = ''.concat(arrVal.path || '', arrVal.value || '', arrVal.name || '', arrVal.indexType || '');
      const v2 = ''.concat(otherVal.path || '', otherVal.value || '', otherVal.name || '', otherVal.indexType || '');
      return v1 === v2;
    });

    async.eachLimit(uniq, 10, (u, eaCb) => {
      u.action = 'remove';
      this._indexField(u, options, eaCb);
    }, fn);
  }

  /*!
   * Creates an instance of this model from raw couchbase document
   * @param getRes
   * @returns {Function}
   */
  static _createModelObject(getRes) {
    if (getRes &amp;&amp; getRes.value) {
      const objData = getRes.value;
      const cas = getRes.cas;
      return new this.prototype.constructor(objData, {}, cas);
    }
  }

  /*!
   * Populate everything
   * @param refs
   * @param options
   * @param memo
   * @param missing
   * @param fn
   */
  _populateAll(refs, options, memo, missing, fn) {
    async.eachLimit(refs, 10, (path, eachCB) => {
      const id = mpath.get(path, this);
      const RefModel = this._getRefModel(path);
      if (!RefModel || !id) {
        return eachCB();
      }

      if (id instanceof RefModel) {
        return eachCB();
      }

      RefModel._findById(id, options, memo, (err, results, missed) => {
        if (err) {
          this._broadcast('error', err, this);
          return eachCB(err);
        }

        if (results) {
          mpath.set(path, results, this);
        }

        if (missed &amp;&amp; missed.length > 0) {
          utils.concatArrays(missing, missed);
        }
        return eachCB();
      });
    }, err => {
      return fn(err, this, missing);
    });
  }

  /*!
   *
   * @param options
   * @param memo
   * @param missing
   * @param fn
   * @returns {*}
   */
  _populatePath(options, memo, missing, fn) {
    const parts = options.populate.path.split('.');
    const part = parts[0];

    // first part must be a ref path and cannot be a digit
    if (!this.schema.hasRefPath(part) || /^\d+$/.test(part)) {
      return process.nextTick(() => {
        return fn(null, this, []);
      });
    }

    let path = part;
    const nextPart = parts[1];
    let restIndex = 1;
    // if next part is an array index append it to path and adjust
    if (nextPart &amp;&amp; /^\d+$/.test(nextPart)) {
      path = part.concat('.', nextPart);
      restIndex = 2;
    }

    // create the rest of path
    let rest;
    if (parts.length > restIndex) {
      rest = parts.slice(restIndex).join('.');
    }

    // get model
    const Model = this._getRefModel(part);
    if (!Model) {
      console.warn('No model for path: %s', part);
      return process.nextTick(() => {
        return fn(null, this, []);
      });
    }

    // get the ref key
    const id = mpath.get(path, this);
    if (!id || id instanceof Model) {
      return process.nextTick(() => {
        return fn(null, this, []);
      });
    }

    // adjust the populate option for the rest
    const opts = clone(options);
    opts.populate.path = rest;

    let targetParts;
    if (_.isString(options.populate.target) &amp;&amp; options.populate.target) {
      targetParts = options.populate.target.split('.');
      opts.populate.target = targetParts.slice(restIndex).join('.');
    }

    // get the ref doc and populate the rest recursively
    Model._findById(id, opts, memo, (err, results, missed) => {
      if (err) {
        this._broadcast('error', err, this);
        return fn(err);
      }
      if (results) {
        let dest = path;
        if (_.isString(options.populate.target) &amp;&amp; options.populate.target) {
          // set up dest based on target similarly to how we did path
          const targetParts = options.populate.target.split('.');
          let targetPath = targetParts[0];
          const nextTargetPart = targetParts[1];
          // if next part is an array index append it to path and adjust
          if (nextTargetPart &amp;&amp; /^\d+$/.test(nextTargetPart)) {
            targetPath = targetPath.concat('.', nextTargetPart);
          }

          dest = targetPath;

          // if populating array element, or within array, lets fill in stuff that's not there first
          const basePath = parts[0];

          let targetProp = mpath.get(targetParts[0], this);
          const temp = clone(mpath.get(basePath, this));
          if (targetProp) {
            targetProp = _.defaultsDeep(targetProp, temp);
          } else {
            targetProp = temp;
          }
        }

        mpath.set(dest, results, this);
      }

      if (missed &amp;&amp; missed.length > 0) {
        utils.concatArrays(missing, missed);
      }

      return fn(err, this, missing);
    });
  }

  /*!
   * Populates embedded documents into this instance based on populate options
   * @param options
   * @param fn
   * @returns {*}
   */
  _populate(options, memo, fn) {
    if (typeof options === 'function') {
      fn = options;
      memo = null;
      options = {};
    }

    if (typeof memo === 'function' &amp;&amp; !fn) {
      fn = memo;
      memo = null;
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!options) {
      options = {};
    }

    if (!cdocUtils.hasPopulate(options)) {
      return process.nextTick(() => {
        return fn(null, this, []);
      });
    }

    const refs = this._getSortedRefPaths(true);
    if (!refs || refs.length === 0) {
      return process.nextTick(() => {
        return fn(null, this, []);
      });
    }

    const missing = [];

    if (options.populate === true) {
      // recursively populate everything
      this._populateAll(refs, options, memo, missing, fn);
    } else if (_.isString(options.populate)) {
      options.populate = { path: options.populate };
      this._populatePath(options, memo, missing, fn);
    } else if (_.isPlainObject(options.populate)) {
      this._populatePath(options, memo, missing, fn);
    } else if (Array.isArray(options.populate)) {
      async.eachLimit(options.populate, 10, (part, eaCb) => {
        const opts = clone(options);
        opts.populate = part;
        return this._populate(opts, memo, eaCb);
      }, err => {
        return fn(err, this, missing);
      });
    }
  }

  /*!
   * emits the event using all of our emitters
   */
  _broadcast() {
    this.emit(...arguments);
    this.constructor.emit(...arguments);
    this[_privateKey].lounge.emit(...arguments);
  }

  /*!
   * calls the callback fn with results based on missing opetions
   */
  static _callback(fn, options, err, result, missing) {
    if (this.config.missing === false) {
      if (options.missing === true) {
        return fn(err, result, missing);
      }

      return fn(err, result);
    }

    if (options.missing === false) {
      return fn(err, result);
    }

    return fn(err, result, missing);
  }

  /*!
   * utility to wrap the callback fn and use our _callback
   */
  static _wrapCallback(fn, options) {
    return (err, result, missing) => {
      return this._callback(fn, options, err, result, missing);
    };
  }

  /**
   * All models created come with a static function &lt;code>findById&lt;/code> that can be used to look up a single
   * or multiple keys and retrieve documents from the database. If key does not exist and document is not found we
   * **do not** return an error but also no model is generated. This is different than present couchbase module behaviour.
   * @param {String|Array} id the document id / key or an array of keys
   * @param {Object} options
   * @param {Boolean|String|Array} options.populate - populate options, can be a &lt;code>Boolean&lt;/code>;
   *                               &lt;code>String&lt;/code> representing a path;
   *                               &lt;code>Object&lt;/code> with form &lt;code>{ path: String, target: String}&lt;/code> where
   *                               &lt;code>path&lt;/code> is the path to be populated and &lt;code>target&lt;/code> is the target
   *                               field into which to populate. If this format is used, &lt;code>target&lt;/code> should be
   *                               part of schema;
   *                               or an &lt;code>Array&lt;/code> of
   *                               &lt;code>Strings&lt;/code> or &lt;code>Object&lt;/code>.
   * @param {Boolean} options.keepSortOrder If getting an array of objects, whether we should keep same sort order of
   *                                        returned objects as the &lt;code>id&lt;/code>'s passed in.
   *                                        Default: &lt;code>false&lt;/code>
   * @param {Boolean} options.missing If set to &lt;code>false&lt;/code> we won't return missing keys as the final param in
   *                                  the callback. This option overwrites the Lounge config &lt;code>missing&lt;/code> option.
   *                                  Default: &lt;code>true&lt;/code>.
   * @param {Function} fn callback
   * @example User.findById('user123', function(err, doc, missing) {
   *   if(err) console.log(err); // there was an error looking up the key
   *   else if(!doc) console.log('no document found');
   *   else console.log(doc); // doc is instance of User and will print it out
   * });
   */
  static findById(id, options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!options) {
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (this.config.alwaysReturnArrays &amp;&amp; !Array.isArray(id)) {
      id = [id];
    }

    if (Array.isArray(id)) {
      id = _.compact(id);
    }

    if (!id || _.isEmpty(id)) {
      return process.nextTick(() => {
        return fn(null, null, []);
      });
    }

    const memo = new MemoDriver(this.db);
    const modelName = this.modelName;
    debug(`${modelName}.findById. id: ${id}`);

    this._findById(id, options, memo, this._wrapCallback(fn, options));
    memo.clear();
  }

  static _findById(id, options, memo, fn) {
    if (typeof memo === 'function' &amp;&amp; !fn) {
      fn = memo;
      memo = null;
    }

    const driver = memo ? memo : this.db;

    if (Array.isArray(id)) {
      const fullIds = _.map(id, curId => {
        return this.getDocumentKeyValue(curId, true);
      });

      driver.get(fullIds, (err, results, misses) => {
        if (err) {
          return fn(err, results, misses);
        }

        if (!results || results.length === 0) {
          return fn(err, [], misses);
        }

        let modelObjs = _.map(results, _.bind(this._createModelObject, this));
        async.eachLimit(modelObjs, 10, (modelObj, eachCB) => {
          modelObj._populate(options, memo, (err, popObj, missed) => {
            if (missed &amp;&amp; missed.length > 0) {
              utils.concatArrays(misses, missed);
            }
            return eachCB(err);
          });
        }, err => {
          if (options.keepSortOrder) {
            modelObjs = _.sortBy(modelObjs, o => {
              return id.indexOf(o.getDocumentKeyValue());
            });
          }
          return fn(err, modelObjs, misses);
        });
      });
    } else {
      id = this.getDocumentKeyValue(id, true);
      driver.get(id, (err, getRes) => {
        if (err) {
          return fn(err);
        }

        const modelObj = this._createModelObject(getRes);
        if (!modelObj) {
          return fn();
        }

        modelObj._populate(options, memo, fn);
      });
    }
  }

  /**
   * Removes specified document(s).
   * @param {String|Array} id - id(s) to remove
   * @param {Object} options - options
   * @param {Boolean} options.lean - if &lt;code>true&lt;/code> we will directly do document removal. We do not create an instance of model.
   *                                 No middleware is invoked. No indexes updated. Embedded documents are not deleted. Default: &lt;code>false&lt;/code>.
   * @param {Boolean} options.removeRefs - If set to &lt;code>true&lt;/code> will remove embedded reference documents. Default: &lt;code>false&lt;/code>.
   * @param {Function} fn - callback
   * @example
   * User.remove('user123', function(err, doc) {
   *   if(err) console.log(err);
   * });
   */
  static remove(id, options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!options) {
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    if (!Array.isArray(id)) {
      id = [id];
    }

    id = _.compact(id);

    if (!id || _.isEmpty(id)) {
      return process.nextTick(() => {
        return fn(null);
      });
    }

    if (options.lean) {
      return async.eachLimit(id, 10, (did, eaCb) => {
        const fullid = this.getDocumentKeyValue(did, true);
        this.db.remove(fullid, eaCb);
      }, fn);
    }

    this.findById(id, (err, docs) => {
      if (err) {
        return fn(err);
      }

      async.eachLimit(docs, 10, (doc, eaCb) => {
        doc.remove(options, eaCb);
      }, fn);
    });
  }

  /*!
   * Find by index document value. generic implementation that we hook up into Models.
   * @param param
   * @param indexPath
   * @param options
   * @param fn
   */
  static _findByIndexValue(param, indexPath, options, fn) {
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    if (!options) {
      options = {};
    }

    if (!fn) {
      fn = _.noop;
    }

    const modelName = this.modelName;
    debug(`${modelName}.findByIndexValue. value: ${param} path: ${indexPath}`);

    this.db.get(param, (err, res) => {
      if (err || !res || !res.value || (!res.value.key &amp;&amp; !res.value.keys)) {
        return fn(err);
      }

      let idToGet = res.value.key || res.value.keys;

      if (options.lean) {
        if (this.config.alwaysReturnArrays &amp;&amp; !Array.isArray(idToGet)) {
          idToGet = [idToGet];
        }
        return fn(err, idToGet);
      }

      return this.findById(idToGet, options, this._wrapCallback(fn, options));
    });
  }
}
</code></pre>
        </article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Jun 06 2016 11:01:51 GMT-0300 (ADT)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
